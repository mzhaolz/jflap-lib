/*
*  JFLAP - Formal Languages and Automata Package
*
*
*  Susan H. Rodger
*  Computer Science Department
*  Duke University
*  August 27, 2009

*  Copyright (c) 2002-2009
*  All rights reserved.

*  JFLAP is open source software. Please see the LICENSE for terms.
*
*/

package edu.duke.cs.jflap.gui.sim;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.swing.JPanel;

import edu.duke.cs.jflap.automata.Automaton;
import edu.duke.cs.jflap.automata.Configuration;

/**
 * The <CODE>ConfigurationPane</CODE> is the pane where the configurations are
 * displayed and selected.
 *
 * @see edu.duke.cs.jflap.automata.Configuration
 *
 * @author Thomas Finley
 */
public class ConfigurationPane extends JPanel implements ActionListener {
	/**
	 *
	 */
	private static final long serialVersionUID = 1L;

	/** The map from configurations to their buttons. */
	private final HashMap<Configuration, ConfigurationButton> configurationToButtonMap = new HashMap<>();

	/** The set of selected configurations. */
	private final HashSet<Configuration> selected = new HashSet<>();

	/** The set of listeners to selection events. */
	private transient HashSet<ConfigurationSelectionListener> selectionListeners = new HashSet<>();

	/**
	 * Creates a <CODE>ConfigurationPane</CODE>. The instance as created has no
	 * configurations loaded into it yet.
	 *
	 * @param automaton
	 *            the automaton that configurations will come from
	 */
	public ConfigurationPane(final Automaton automaton) {
	}

	/**
	 * Responds to actions, presumably generated by some button belonging to
	 * this view.
	 *
	 * @param e
	 *            the action event generated
	 */
	@Override
	public void actionPerformed(final ActionEvent e) {
		ConfigurationButton button = null;
		try {
			button = (ConfigurationButton) e.getSource();
		} catch (final ClassCastException ex) {
			return; // Then, we don't care.
		}
		final Configuration config = button.getConfiguration();
		if (!configurationToButtonMap.containsKey(config)) {
			return;
		}
		if (button.isSelected()) {
			selected.add(config);
		} else {
			selected.remove(config);
		}
		distributeSelectionEvent(new ConfigurationSelectionEvent(this));
	}

	/**
	 * Adds a configuration to the configuration pane.
	 *
	 * @param configuration
	 *            the configuration to add
	 */
	public void add(final Configuration configuration) {
		add(configuration, ConfigurationButton.NORMAL);
	}

	/**
	 * Adds configurations with the given state.
	 *
	 * @param configuration
	 *            the configuration to add q *
	 * @param state
	 *            the state of the configuration, either NORMAL, ACCEPT, REJECT,
	 *            or FREEZE
	 */
	public void add(final Configuration configuration, final int state) {
		if (contains(configuration)) {
			return;
		}
		final ConfigurationButton button = new ConfigurationButton(configuration, state);
		configurationToButtonMap.put(configuration, button);
		add(button);
		button.addActionListener(this);
	}

	/**
	 * Adds a <CODE>ConfigurationSelectionListener</CODE> to this object.
	 *
	 * @param listener
	 *            the listener to add
	 */
	public void addSelectionListener(final ConfigurationSelectionListener listener) {
		selectionListeners.add(listener);
	}

	/**
	 * Removes all configurations from this pane.
	 */
	public void clear() {
		configurationToButtonMap.clear();
		selected.clear();
		super.removeAll();
	}

	/**
	 * Clears out all configurations which are "final" configurations, i.e.,
	 * those that are marked either as accept or reject configurations.
	 */
	public void clearFinal() {
		// Avoid concurrent modification exceptions.
		final ArrayList<ConfigurationButton> list = new ArrayList<>();
		list.addAll(configurationToButtonMap.values());
		final Iterator<ConfigurationButton> it = list.iterator();

		while (it.hasNext()) {
			final ConfigurationButton button = it.next();
			if (button.state == ConfigurationButton.ACCEPT || button.state == ConfigurationButton.REJECT) {
				remove(button.getConfiguration());
			}
		}
	}

	/**
	 * Clears old all configurations which are not frozen.
	 */
	public void clearThawed() {
		// Avoid concurrent modification exceptions.
		final ArrayList<ConfigurationButton> list = new ArrayList<>();
		list.addAll(configurationToButtonMap.values());
		final Iterator<ConfigurationButton> it = list.iterator();

		while (it.hasNext()) {
			final ConfigurationButton button = it.next();
			if (button.state != ConfigurationButton.FREEZE) {
				remove(button.getConfiguration());
			}
		}
	}

	/**
	 * Determines if this pane already contains this configuration.
	 *
	 * @param configuration
	 *            the configuration to test for membership
	 * @return <CODE>true</CODE> if the pane holds this transition,
	 *         <CODE>false</CODE> if it does not
	 */
	public boolean contains(final Configuration configuration) {
		return configurationToButtonMap.containsKey(configuration);
	}

	/**
	 * @param configuration
	 */
	public void defocus(final Configuration configuration) {
		setNormal(configuration);
		Configuration parent = configuration;
		parent.setFocused(false);
		while (parent.getParent() != null) {
			parent = parent.getParent();
			parent.setFocused(false);
		}
	}

	/**
	 * Renders all components deselected.
	 */
	public void deselectAll() {
		selected.clear();
	}

	/**
	 * Gives a <CODE>ConfigurationSelectionEvent</CODE> to all listeners.
	 *
	 * @param listener
	 *            the listener to add
	 */
	void distributeSelectionEvent(final ConfigurationSelectionEvent event) {
		final Iterator<ConfigurationSelectionListener> it = selectionListeners.iterator();
		while (it.hasNext()) {
			final ConfigurationSelectionListener listener = it.next();
			listener.configurationSelectionChange(event);
		}
	}

	/**
	 * Returns an array of all configurations.
	 *
	 * @return an array of all configurations
	 */
	public Set<Configuration> getConfigurations() {
		return configurationToButtonMap.keySet();
	}

	/**
	 * Returns an array of selected configurations.
	 *
	 * @return an array of selected configurations
	 */
	public Set<Configuration> getSelected() {
		return selected;
	}

	/**
	 * Given a configuration, returns the state for that configuration.
	 *
	 * @param configuration
	 *            the configuration
	 * @return the state for that configuration
	 */
	public int getState(final Configuration configuration) {
		return configurationToButtonMap.get(configuration).state;
	}

	/**
	 * Returns an array of configurations that are, as far as is known, valid
	 * configurations for moving to other configurations.
	 *
	 * @return an array of "valid" configurations
	 */
	public List<Configuration> getValidConfigurations() {
		// A state is valid for return if it is normal.
		final ArrayList<Configuration> list = new ArrayList<>();
		final Iterator<ConfigurationButton> it = configurationToButtonMap.values().iterator();
		while (it.hasNext()) {
			final ConfigurationButton button = it.next();
			if (button.state == ConfigurationButton.NORMAL || button.state == ConfigurationButton.FOCUSED) {
				list.add(button.getConfiguration());
			}
		}
		return list;
	}

	/**
	 * Removes a configuration from the configuration pane.
	 *
	 * @param configuration
	 *            the configuration to remove
	 */
	public void remove(final Configuration configuration) {
		final Component comp = configurationToButtonMap.remove(configuration);
		if (comp == null) {
			return;
		}
		selected.remove(configuration);
		remove(comp);
	}

	/**
	 * Remove a <CODE>ConfigurationSelectionListener</CODE> from this object.
	 *
	 * @param listener
	 *            the listener to remove
	 */
	public void removeSelectionListener(final ConfigurationSelectionListener listener) {
		selectionListeners.remove(listener);
	}

	public void setFocused(final Configuration configuration) {
		final ConfigurationButton button = configurationToButtonMap.get(configuration);
		if (button == null) {
			return;
		}
		if (button.state == ConfigurationButton.NORMAL) {
			// System.out.println("Setting color");
			button.setState(ConfigurationButton.FOCUSED);
			button.doClick();
		}
	}

	/**
	 * Sets a configuration to be frozen. Only normal configurations can be
	 * frozen.
	 *
	 * @param configuration
	 *            the configuration to freeze
	 */
	public void setFrozen(final Configuration configuration) {
		final ConfigurationButton button = configurationToButtonMap.get(configuration);
		if (button == null) {
			return;
		}
		if (button.state == ConfigurationButton.NORMAL) {
			button.setState(ConfigurationButton.FREEZE);
		}
		button.doClick();
	}

	/**
	 * Sets a configuration to be normal.
	 *
	 * @param configuration
	 *            the configuration to thaw or unfocus
	 */
	public void setNormal(final Configuration configuration) {
		final ConfigurationButton button = configurationToButtonMap.get(configuration);
		if (button == null) {
			return;
		}
		if (button.state == ConfigurationButton.FREEZE) {
			button.setState(ConfigurationButton.NORMAL);
		} else if (button.state == ConfigurationButton.FOCUSED) {
			button.setState(ConfigurationButton.NORMAL);
		}
		button.doClick();
	}

	/**
	 * Sets a configuration to be a reject configuration.
	 *
	 * @param configuration
	 *            the configuration to set to be a reject configuration
	 */
	public void setReject(final Configuration configuration) {
		final ConfigurationButton button = configurationToButtonMap.get(configuration);
		if (button == null) {
			return;
		}
		if (button.state == ConfigurationButton.NORMAL) {
			button.setState(ConfigurationButton.REJECT);
		}
		button.doClick();
	}
}
